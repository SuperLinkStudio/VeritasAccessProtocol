# Veritas Access Protocol (VAP) 1.0 文档

Veritas Access Protocol (VAP) 是一种**专门用于资源管理访问令牌使用阶段**的安全协议，旨在保障客户端与服务端之间受保护数据的交互安全。

## 术语表

### 凭证

| 名称                 | 解释                                                                                 |
| -------------------- | ------------------------------------------------------------------------------------ |
| `code`               | 资源访问令牌兑换码，有效期为 5 min。                                                 |
| `expire_time`        | 到期时间，为 `yyyy-MM-dd HH:mm:ss` 格式                                              |
| `access_token`       | 资源访问令牌，由认证服务器颁发，用于客户端向资源服务器证明其已获授权访问特定用户数据 |
| `account_id`         | 用户唯一标识符，由认证服务器分配                                                     |
| `client_id`          | 客户端唯一标识符，由认证服务器分配                                                   |
| `resource_server_id` | 资源服务器唯一标识符，由认证服务器分配                                               |

### 角色

| 角色       | 解释                                                                                            |
| ---------- | ----------------------------------------------------------------------------------------------- |
| 用户       | 使用客户端并作为其个人数据所有者的一方                                                          |
| 客户端     | 依据 VAP 协议向资源服务器请求访问用户数据的一方                                                 |
| 认证服务器 | 负责用户身份认证、向客户端颁发 `access_token`、并向资源服务器提供 `access_token` 验证服务的一方 |
| 资源服务器 | 存储并提供用户数据的一方或多方                                                                  |
| 服务端     | 认证服务器与资源服务器的统称                                                                    |

> [!TIP]
> 有时资源服务器与认证服务器是同一个主体。

### 算法相关

| 名称 / 概念  | 解释                                                                                                                                                     |
| ------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| TDT          | 一种用于生成固定长度、不可逆且无时间窗口滞留的字节数组的算法，详情可参考 [Time-Based Deterministic Token 算法](#time-based-deterministic-token-tdt-算法) |
| `tdt`        | 一段由 TDT 算法生成的字节数组                                                                                                                            |
| TDT 值       | TDT 算法的结果                                                                                                                                           |
| `tdt_secret` | TDT 算法的共享密钥，由**认证服务器**生成并安全分发给通信双方                                                                                             |

## 信息加密传输要求

Veritas Access Protocol 中定义了需要实施加密与签名的数据内容。

作为专门用于管理访问令牌使用阶段的安全协议，本协议**不会强制规定**具体加密、签名方案。此设计旨在为认证服务器与客户端提供更高的灵活性，使其能够不断更新并采用更高安全级别的加密与签名机制。

作为**最低安全要求**，应至少采用 **X25519** 算法和 **Ed25519** 算法的组合方案。

具体的加密算法、密钥分配、密钥轮换等流程由**认证服务器**规定。

### 字段加密格式示例

在[核心操作流程](#核心操作流程)中，以 `tdt` 为例，对于加密字段的解释会添加一段标识，如下:

| 字段             | 解释                                                |
| ---------------- | --------------------------------------------------- |
| ……               | ……                                                  |
| `tdt`            | (由**客户端**加密并签名) TDT 值                     |
| `<被加密的字段>` | (由`<执行加密的一方>`加密并签名) `<对于字段的解释>` |
| ……               | ……                                                  |

加密字段必须封装为 JSON 对象，其结构如下:

```json
// 示例结构，实际内容取决于所选用的加密算法以及认证服务器要求
"<被加密并签名的字段>": {
  "ciphertext": "<密文>",
  "signature": "<签名>"
}
```

在 POST 请求中，包含加密字段的请求体结构示例如下：

```json
{
  "...": "...",
  "tdt": {
    "ciphertext": "<加密数据>",
    "signature": "<签名值>"
  },
  "...": "..."
}
```

## Time-Based Deterministic Token (TDT) 算法

一种结合了时间戳、密钥和哈希处理，生成固定长度、不可逆且无时间窗口滞留的字节数组的算法。

### 用途

该算法被设计用于：

- 辅助验证资源服务器和客户端身份
- 抵抗重放攻击，保护用户数据

### 算法内容

#### 输入

| 名称            | 用途                      |
| --------------- | ------------------------- |
| `tdt_secret`    | 密钥 (UTF-8 字符串)       |
| `timestamp`     | **毫秒级** **UTC** 时间戳 |
| `result_length` | 结果长度 (默认为 256)     |

#### 输出

长度为 `result_length` 的字节数组（`byte[]`）

#### 流程

1. 将 `tdt_secret` 通过 UTF-8 编码转换为字节数组，得到 `secret_bytes`
2. 将 `timestamp` 转换为 **8 字节大端序** 字节数组
3. 以 `tdt_secret` 为密钥，对 `timestamp` 使用 **KMAC128** 算法计算生成最终结果，长度为 `result_length`

> [!IMPORTANT]
>
> - 输入时间戳应当为 8 字节无符号整数
> - 算法中，时间戳转换为字节数组时采用大端序 (Big-Endian)
> - 核心令牌生成使用固定域分离标签 "5beeb687e266"

#### 伪代码示例

```
function GenerateTDT(tdt_secret: string, timestamp: int, resultLength: int = 256) -> bytes:
    # 将密钥通过 UTF-8 编码转换为字节数组
    secret_bytes = tdt_secret.encode('utf-8')

    # 时间戳转换 (大端序 8字节)
    timestamp_bytes = timestamp.to_bytes(8, 'big')

    # KMAC128 核心令牌生成 (抗量子MAC)
    result = kmac128(
        key = secret_bytes,
        data = timestamp_bytes,
        output_len = resultLength,  # 输出长度为 resultLength
        customization = "5beeb687e266"  # 固定域分离标签
    )

    return result
```

验证 TDT 值时，可以：

```
function ValidateTDT(tdt: byte[], secret: string, timestamp: int64) -> bool:
    // 获取 tdt 长度
    resultLength = getByteLength(tdt)

    // 用同样的参数代入生成 generatedTDT
    generatedTDT = GenerateTDT(secret, timestamp, resultLength)

    // 判断 tdt 与 generatedTDT 是否相等并返回结果
    return HMAC.compareDigest(tdt, generatedTDT);
```

### 其它要求

在 Veritas Access Protocol 协议中使用 TDT 算法时，**必须**严格遵守以下要求:

- `result_length` 参数不应小于 256。
- `tdt_secret` 长度不得小于为 32 字节
- 在实现算法文档的伪代码示例中 `ValidateTDT` 函数 (或任何功能等效的 TDT 验证函数) 时，**必须**使用具备恒定时间比较特性的函数来比较两个 TDT 值 (例如 HMAC 算法中常见的 `compareDigest` 函数) 。**禁止**使用普通的字节数组比较操作，以防止潜在的时序攻击漏洞。恒定时间比较确保验证操作所需的时间不依赖于 TDT 值本身的匹配程度。

### `tdt_secret` 生成

`tdt_secret` 生成方案应当由**认证服务器**规定。同理，此设计旨在为认证服务器与客户端提供更高的灵活性，使其能够不断更新并提高安全性。

作为**最低安全要求**，应至少采用随机且全局唯一的 SHA256 哈希值。

同时，以下内容为硬性标准:

- 将 `tdt_secret` 通过 UTF-8 编码转换为字节数组后，得到的的字节数组长度必须满足 **≥32 字节** 要求
- 禁止使用非规范化 Unicode 字符串（需 NFC 规范化）

### 时间同步

**发送方**和**认证服务器**之间的时间同步解决方案应当由**认证服务器**规定。此设计仍然旨在为认证服务器与客户端提供更高的灵活性，使其能够不断更新并提高安全性。

作为**最低安全要求**，**认证服务器**应当指定信任的 NTP 服务器实现各方之间的时间同步。对于采用**最低安全要求**的，我们强烈建议启用 RFC 8915 认证扩展。

### TDT 密钥轮换

本协议**不会强制规定**具体 `tdt_secret` 轮换方案。此设计依旧旨在为认证服务器与客户端提供更高的灵活性，使其能够不断更新并采用更高安全级别的 `tdt_secret` 轮换方案。

若发生密钥泄露，**认证服务器**必须立即吊销旧密钥，并通过安全通道分发新密钥给所有持有方。

### `tdt` 传输流程

假设**发送方**和**认证服务器**共同持有同一 TDT 密钥 `tdt_secret`。且在此之前**发送方**和**认证服务器**已经按照**认证服务器**规定的方式进行时间同步

**发送方**操作:

1. 使用 `tdt_secret` 和**发送方**当前的毫秒级 UTC 时间戳 `current_timestamp` 生成 TDT 值 `tdt_value`。
2. 将 `current_timestamp` 和 `tdt_value` 用空格隔开，生成 `tdt_message`
3. 将 `tdt_message` 依据[信息加密传输要求](#信息加密传输要求)和**认证服务器**规定的方法签名、加密、封装，得到 JSON 字符串 `tdt`
4. 依据 VAP [核心操作流程](#核心操作流程)，以规定的形式发送 `tdt`

**认证服务器**操作:

1. 依据 VAP [核心操作流程](#核心操作流程)，以规定的形式接收 `tdt`
2. 使用[信息加密传输要求](#信息加密传输要求)和**认证服务器**规定的方法对 `tdt` 解密、验签，得到 `tdt_message`
3. 将 `tdt_message` 以第一个空格作为分界线进行分割，按顺序得到时间戳 `current_timestamp` 和 `tdt_value`
4. 将 `current_timestamp` 与 **认证服务器**当前的毫秒级 UTC 时间戳进行比较，误差的绝对值必须小于 `timestamp_offset`
5. 获取存储的时间戳 `last_timestamp` (首次验证时或 `last_timestamp` 过期时跳过这一步)
6. 将 `current_timestamp` 与 `last_timestamp` 进行比较，`current_timestamp` 必须大于 `last_timestamp` (首次验证时或 `last_timestamp` 过期时跳过这一步)
7. 依据 `current_timestamp` 和 `tdt_secret` 验证 `tdt_value`
8. 将 `current_timestamp` 作为 `last_timestamp` 进行存储

> [!IMPORTANT]
>
> - `timestamp_offset` 的单位为毫秒，具体大小由**认证服务器**综合规定，但**禁止大于** 60000，即 1min
> - 对于 `last_timestamp` 的存储必须持久化，以对抗重放攻击。
> - `last_timestamp` 应当与(**资源服务器的**)唯一标识符或(**客户端的**)资源访问令牌关联存储。

#### `last_timestamp` 过期的的判定标准

该判定标准应当由**认证服务器**规定，以下为**最低安全要求**:

已知 `current_timestamp`、`last_timestamp` 与 `timestamp_offset`，当:

```
last_timestamp + (2 * timestamp_offset) < current_timestamp
```

时，判定 `last_timestamp` 过期。**认证服务器**可安全丢弃过期的 `last_timestamp`。

## 核心操作流程

本章节将描述 VAP 协议的核心操作流程，包括客户端和认证服务器之间的交互步骤。

VAP 协议允许**认证服务器**在核心操作流程前、后插入自定义流程以**满足安全性需要**与**特定业务需求**。同时，允许允许**认证服务器**在核心操作流程中要求加入自定义字段。

### 客户端上线前

该流程应当由客户端的开发者完成，客户端的开发者应当在**认证服务器的官方网站中**或**线下**向认证服务器完成注册。

VAP 协议不涉及注册时具体流程，但是客户端应当向认证服务器提供以下信息:

| 名称                      | 解释                                                 |
| ------------------------- | ---------------------------------------------------- |
| `after_auth_redirect_url` | 用户身份认证结束后，认证服务器将把用户重定向到的地址 |

当注册结束时，认证服务器至少应当生成如下信息:

| 名称            | 应向客户端的开发者提供 | 解释                                    |
| --------------- | ---------------------- | --------------------------------------- |
| `client_id`     | 必须                   | 客户端唯一标识符                        |
| `tdt_secret`    | 必须                   | 客户端的 TDT 算法密钥，该值应当全局唯一 |
| `authorize_url` | 应当                   | 用户身份认证界面地址                    |
| `redeem_url`    | 应当                   | 资源访问令牌兑换 API 地址               |
| `update_url`    | 应当                   | 资源访问令牌更新 API 地址               |
| `destroy_url`   | 应当                   | 资源访问令牌销毁 API 地址               |

客户端必须对认证服务器所提供的信息进行保密，并做好充足的防泄漏措施。

### 资源服务器上线前

该流程应当由资源服务器的开发者完成，资源服务器的开发者应当在**认证服务器的官方网站中**或**线下**向认证服务器完成注册。

VAP 协议不涉及注册时具体流程，但是资源服务器应当向认证服务器提供并且对外公开以下信息:

| 名称           | 解释                                                                                                                                                                                                          |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `service_name` | 资源服务器名称                                                                                                                                                                                                |
| `resource_url` | 用户数据访问 API 地址                                                                                                                                                                                         |
| `scope_names`  | (字符串数组) 资源服务器提供的数据范围名称列表，对于其中每一个元素 `scope_name`，都是格式为 `<scope>:<data_name>` 的字符串，表示资源服务器提供的数据范围名称，具体细则请参考 [scope 命名规范](#scope-命名规范) |

> [!TIP]
> 注意: `service_name` 和 `scope_name` 应当遵循下划线命名法，禁止包含空格，且不应包含大写字母，不推荐使用拼音。

当注册结束时，认证服务器至少应当生成如下信息:

| 名称                 | 应向资源服务器的开发者提供 | 解释                                        |
| -------------------- | -------------------------- | ------------------------------------------- |
| `resource_server_id` | 必须                       | 资源服务器唯一标识符                        |
| `tdt_secret`         | 必须                       | 资源服务器的 TDT 算法密钥，该值应当全局唯一 |
| `authentication_url` | 应当                       | 客户端资源访问令牌鉴权 API 地址             |

资源服务器必须对认证服务器所提供的信息进行保密，并做好充足的防泄漏措施。

### 客户端获取资源访问令牌

该流程应当在客户端尝试获取用户信息前完成。

1. **客户端**将**用户**重定向到**认证服务器**的 `authorize_url`，并附上以下内容作为查询:

   | 内容        | 解释                                             |
   | ----------- | ------------------------------------------------ |
   | `client_id` | 客户端唯一标识符                                 |
   | `scope`     | 客户端将要被授权访问的数据范围，多个，由空格隔开 |

2. **用户**在**认证服务器**处完成用户身份认证，向**用户**展示**客户端**的 `scope` 并询问是否授权

   VAP 协议不涉及用户身份认证其余具体细节。

   建议认证服务器允许用户自行缩小 `scope` 范围。

3. **认证服务器**将**用户**重定向到**客户端**的 `after_auth_redirect_url`，并附上以下内容作为查询:

   | 内容   | 解释                                                              |
   | ------ | ----------------------------------------------------------------- |
   | `code` | (由**认证服务器**加密并签名，以字符串形式传输) 资源访问令牌兑换码 |

4. **客户端**向**认证服务器**的 `redeem_url` 发送 `POST` 请求，并附上以下内容作为 Body 部分:

   | 内容        | 解释                                        |
   | ----------- | ------------------------------------------- |
   | `client_id` | 客户端唯一标识符                            |
   | `code`      | (由**客户端**加密并签名) 资源访问令牌兑换码 |
   | `tdt`       | (由**客户端**加密并签名) TDT 值             |

5. **认证服务器**生成 `access_token` 并**销毁 `code`**

   要求：

   - `access_token` 必须是**独一无二**的
   - 将 `access_token` 与 `client_id` 相关联并持久化存储其关系

6. **认证服务器**对于来自**客户端**的请求返回如下内容:

   | 内容           | 解释                                      |
   | -------------- | ----------------------------------------- |
   | `access_token` | (由**认证服务器**加密并签名) 资源访问令牌 |
   | `expire_time`  | 到期时间，为 `yyyy-MM-dd HH:mm:ss` 格式   |

### 客户端获取用户数据

该流程应当在客户端获取资源访问令牌之后、资源访问令牌被销毁之前完成。

1. **客户端**向**资源服务器**的 `resource_url` 发送 `POST` 请求，并附上以下内容作为 Body 部分:

   | 内容           | 解释                                                                                                    |
   | -------------- | ------------------------------------------------------------------------------------------------------- |
   | `client_id`    | 客户端唯一标识符                                                                                        |
   | `access_token` | (**客户端**与**认证服务器**之间，由**客户端**加密并签名) 资源访问令牌                                   |
   | `scope`        | (**客户端**与**认证服务器**之间，由**客户端**加密并签名) 客户端将要尝试访问的数据范围，多个，由空格隔开 |
   | `tdt`          | (**客户端**与**认证服务器**之间，由**客户端**加密并签名) TDT 值                                         |

2. **资源服务器**向**认证服务器**的 `authentication_url` 发送 `POST` 请求，并附上以下内容作为 Body 部分:

   | 内容                  | 解释                                                                    |
   | --------------------- | ----------------------------------------------------------------------- |
   | `resource_server_id`  | 资源服务器唯一标识符                                                    |
   | `scope`               | 客户端 `scope`，原样发送                                                |
   | `client_id`           | 客户端 `client_id`，原样发送                                            |
   | `client_access_token` | 客户端 `access_token`，原样发送                                         |
   | `client_tdt`          | 客户端 `tdt`，原样发送                                                  |
   | `tdt`                 | (**资源服务器**与**认证服务器**之间，由**资源服务器**加密并签名) TDT 值 |

3. **认证服务器** 验证并确定以下内容有效:

   - `scope`
   - `client_id`
   - `client_access_token`
   - `client_tdt`
   - `tdt`

4. **认证服务器**对于来自**资源服务器**的请求返回如下内容:

   | 内容                   | 解释                                                                                                            |
   | ---------------------- | --------------------------------------------------------------------------------------------------------------- |
   | `scope`                | (**认证服务器**与**资源服务器**之间，由**认证服务器**加密并签名) 认证服务器允许客户端访问的数据范围             |
   | `scope_to_client`      | (**认证服务器**与**客户端**之间，由**认证服务器**加密并签名) 认证服务器允许客户端访问的数据范围                 |
   | `account_id`           | (**认证服务器**与**资源服务器**之间，由**认证服务器**加密并签名) 客户端 `access_token` 所绑定的用户的唯一标识符 |
   | `account_id_to_client` | (**认证服务器**与**客户端**之间，由**认证服务器**加密并签名) 客户端 `access_token` 所绑定的用户的唯一标识符     |

5. **资源服务器**对于来自**客户端**的请求返回如下内容:

   | 内容         | 解释                                        |
   | ------------ | ------------------------------------------- |
   | `scope`      | 认证服务器 `scope_to_client`，原样发送      |
   | `account_id` | 认证服务器 `account_id_to_client`，原样发送 |
   | `user_data`  | (由**资源服务器**加密并签名) 用户数据       |

   `user_data` 原文应当是一个符合 `RFC 8259` 标准的 `JSON` 文本，以每个 `scope` 为 Key， 以每个 `scope` 所对应的用户数据为 Value。对于非数据的 `scope`，其对应 Value 应当为 null，即空值。

   `user_data` 原文示例:

   ```JSON
   {
    "authorize:account_data:name": "A White Cat",
    "authorize:account_data:bio": "I am a white cat",
    "service:file:delete": null
   }
   ```

### 客户端更新资源访问令牌

该流程应当在客户端获取资源访问令牌之后、资源访问令牌将要或已经到期之时、资源访问令牌被销毁之前完成。

1. **客户端**向**认证服务器**的 `update_url` 发送 `POST` 请求，并附上以下内容作为 Body 部分:

   | 内容           | 解释                                      |
   | -------------- | ----------------------------------------- |
   | `client_id`    | 客户端唯一标识符                          |
   | `access_token` | (由**客户端**加密并签名) 旧的资源访问令牌 |
   | `tdt`          | (由**客户端**加密并签名) TDT 值           |

2. **认证服务器**对于来自**客户端**的请求返回如下内容:

   | 内容           | 解释                                          |
   | -------------- | --------------------------------------------- |
   | `access_token` | (由**认证服务器**加密并签名) 新的资源访问令牌 |
   | `expire_time`  | 到期时间，为 `yyyy-MM-dd HH:mm:ss` 格式       |

获取到新的资源访问令牌后，旧的资源访问令牌将保留一段时间 (具体时长由**认证服务器**规定，此时旧令牌被标记为弃用，不会因为新令牌刷新而被复写)，留出处理异常的余地，出现异常后客户端应当立刻以手中现有令牌更新资源访问令牌。

### 客户端销毁资源访问令牌

该流程应当在客户端主动毁资源访问令牌之时完成。

1. **客户端**向**认证服务器**的 `delete_url` 发送 `POST` 请求，并附上以下内容作为 Body 部分:

   | 内容           | 解释                                  |
   | -------------- | ------------------------------------- |
   | `client_id`    | 客户端唯一标识符                      |
   | `access_token` | (由**客户端**加密并签名) 资源访问令牌 |
   | `tdt`          | (由**客户端**加密并签名) TDT 值       |

2. **认证服务器**销毁**客户端**计划销毁的资源访问令牌

3. **认证服务器**对于来自**客户端**的请求返回如下内容:

   ```http
   200 OK
   ```

## scope 命名规范

### 基本结构

所有 scope 名称必须采用三级命名空间结构：

```
<service_name>:<scope>:<data_name>
```

但是，当需要的数据范围包含某一 scope_group 下的所有 scope_name 时，可使用以下简写形式:

```
<service_name>:<scope>
```

### 命名规则

| 组成部分       | 规则           |
| -------------- | -------------- |
| `service_name` | 资源服务器名称 |
| `scope`        | 数据范围分组   |
| `data_name`    | 单个数据名称   |

例如：

```
authorize:account_data:name
```

`service_name`、`scope_group` 和 `scope_name` 应当遵循下划线命名法，禁止包含空格，且不应包含大写字母，不推荐使用拼音。

## 网络请求规范

VAP 协议所涉及的所有网络请求 (重定向除外) 均**必须**使用 `POST` 请求，并严格遵守以下规定:

- 请求头 Content-Type 必须设置为 `application/json`
- 所有请求参数和返回数据必须通过 Body 传输
- 禁止在 URL 查询参数、Header 或 Cookie 中传递敏感数据
- Body 数据必须为严格符合 `RFC 8259` 标准的 `JSON` 格式

VAP 协议强制要求使用 `HTTPS`。

## 错误处理与错误码

对于任何请求**认证服务器**或**资源服务器**服务的一方 (以下简称: 请求方) 信息验证不通过、密钥错误、请求格式错误等问题和异常，**认证服务器**或**资源服务器**统一回复以下格式的信息:

```json
{
  "error": "<error_code>"
}
```

其中，`error_code` 为错误码。

### 标准错误码表

| 错误码                | 解释                                 |
| --------------------- | ------------------------------------ |
| `unknown_id`          | 请求方提供的统一标识符不存在         |
| `tdt_error`           | 请求方提供的 `tdt` 异常              |
| `encrypt_error`       | 密文或签名等与加密相关的信息的异常   |
| `unknown_code`        | 请求方提供的资源访问令牌兑换码不存在 |
| `unknown_client_id`   | 请求方提供的资源访问令牌不存在       |
| `outdated_client_id`  | 请求方提供的资源访问令牌已过期       |
| `old_client_id`       | 请求方提供的资源访问令牌弃用         |
| `outdated_secret_key` | 请求方的密钥已过期                   |
| `security_exception`  | 安全性出现异常                       |
| `refuse_service`      | 出现了未知异常，拒绝提供服务         |

## 针对向认证服务器预留的可规定空间的补充说明

在 VAP 协议中，包含了许多预留的可规定空间。该设计旨在为未来的扩展和定制化需求提供灵活性和可操作性。

对于**认证服务器**来说，使用这些可规定空间应当为了**满足安全性需要**与**特定业务需求**。

协议中规定的最低安全规范是**最低的安全性底线**。若不使用最低安全规范，则目的**只能是带来安全性升级**。协议强烈反对和谴责任何试图降低安全性标准的行为。
